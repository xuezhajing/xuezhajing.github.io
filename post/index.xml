<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on My New Hugo Site</title>
    <link>https://xuezhajing.github.io/post/</link>
    <description>Recent content in Posts on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 20 Oct 2023 19:30:19 +0800</lastBuildDate><atom:link href="https://xuezhajing.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JVM垃圾回收</title>
      <link>https://xuezhajing.github.io/post/jvm/</link>
      <pubDate>Fri, 20 Oct 2023 19:30:19 +0800</pubDate>
      
      <guid>https://xuezhajing.github.io/post/jvm/</guid>
      <description>一、那些内存需要回收 猿们都知道JVM的内存结构包括五大区域：程序计数器、虚拟机栈、本地方法栈、堆区、方法区。其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生、随线程而灭，因此这几个区域的内存分配和回收都具备确定性，就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。而Java堆区和方法区则不一样、不一样!这部分内存的分配和回收是动态的，正是垃圾收集器所需关注的部分。
垃圾收集器在对堆区和方法区进行回收前，首先要确定这些区域的对象哪些可以被回收，哪些暂时还不能回收，这就要用到判断对象是否存活的算法！（面试官肯定没少问你吧）
1.1 引用计数算法 1. 算法分析 引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，就将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。
2 . 优缺点 - 优点：引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。 - 缺点：无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0。 public class abc_test { public static void main(String[] args) { // TODO Auto-generated method stub MyObject object1=new MyObject(); MyObject object2=new MyObject(); object1.object=object2; object2.object=object1; object1=null; object2=null; } } class MyObject{ MyObject object; } 这段代码是用来验证引用计数算法不能检测出循环引用。最后面两句将object1和object2赋值为null，也就是说object1和object2指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数器都不为0，那么垃圾收集器就永远不会回收它们。
1.2 可达性分析算法 1. 算法分析 达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点，无用的节点将会被判定为是可回收的对象。
在java语言中，可作为`GC ROOT`的对象包括下面集中: - a.虚拟机站中引用的对象(栈帧中的本地变量表)。 - b.方法区中类静态属性引用的对象。 - c.方法区中常量引用的对象。 - d.本地方法栈中JNI(Native方法)引用的对象。 这个算法的基本思路：通过一系列称为&amp;quot;GC ROOT&amp;quot;的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到FC ROOT没有任何引用链相连（用图论的话来说，就是从GC ROOTS到这个对象不可达）时，则证明次对象是不可用的。如图所示，对象object 5、object 6、object 7 虽然互相有关联，但是他们到GC ROOTS是不可达的，所以他们将会被判定为 可回收对象。</description>
    </item>
    
    <item>
      <title>红黑树</title>
      <link>https://xuezhajing.github.io/post/blog/</link>
      <pubDate>Fri, 20 Oct 2023 19:30:19 +0800</pubDate>
      
      <guid>https://xuezhajing.github.io/post/blog/</guid>
      <description>【摘要】 二叉查找树（BST）具备什么特性呢？1.左子树上所有结点的值均小于或等于它的根结点的值。2.右子树上所有结点的值均大于或等于它的根结点的值。3.左、右子树也分别为二叉排序树。下图中这棵树，就是一颗典型的二叉查找树：假设初始的二叉查找树只有三个节点，根节点值为9，左孩子值为8，右孩子值为12：接下来我们依次插入如下五个节点：7,6,5,4,3。依照二叉查找树的特性，结果会变成什么样呢？1.节点&amp;hellip;
二叉查找树（BST）具备什么特性呢？
1.左子树上所有结点的值均小于或等于它的根结点的值。
2.右子树上所有结点的值均大于或等于它的根结点的值。
3.左、右子树也分别为二叉排序树。
下图中这棵树，就是一颗典型的二叉查找树：
假设初始的二叉查找树只有三个节点，根节点值为9，左孩子值为8，右孩子值为12：
接下来我们依次插入如下五个节点：7,6,5,4,3。依照二叉查找树的特性，结果会变成什么样呢？
1.节点是红色或黑色。
2.根节点是黑色。
3.每个叶子节点都是黑色的空节点（NIL节点）。
4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。
下图中这棵树，就是一颗典型的红黑树：
什么情况下会破坏红黑树的规则，什么情况下不会破坏规则呢？我们举两个简单的栗子：
1.向原红黑树插入值为14的新节点：
由于父节点15是黑色节点，因此这种情况并不会破坏红黑树的规则，无需做任何调整。
2.向原红黑树插入值为21的新节点：
由于父节点22是红色节点，因此这种情况打破了红黑树的规则4（每个红色节点的两个子节点都是黑色），必须进行调整，使之重新符合红黑树的规则。
变色：
为了重新符合红黑树的规则，尝试把红色节点变为黑色，或者把黑色节点变为红色。
下图所表示的是红黑树的一部分，需要注意节点25并非根节点。因为节点21和节点22连续出现了红色，不符合规则4，所以把节点22从红色变成黑色：
但这样并不算完，因为凭空多出的黑色节点打破了规则5，所以发生连锁反应，需要继续把节点25从黑色变成红色：
此时仍然没有结束，因为节点25和节点27又形成了两个连续的红色节点，需要继续把节点27从红色变成黑色：
左旋转：
逆时针旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子。说起来很怪异，大家看下图：
图中，身为右孩子的Y取代了X的位置，而X变成了自己的左孩子。此为左旋转。
右旋转：
顺时针旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子。大家看下图：
图中，身为左孩子的Y取代了X的位置，而X变成了自己的右孩子。此为右旋转。
我们以刚才插入节点21的情况为例：
此时节点17和节点25是连续的两个红色节点，那么把节点17变成黑色节点？恐怕不合适。这样一来不但打破了规则4，而且根据规则2（根节点是黑色），也不可能把节点13变成红色节点。
变色已无法解决问题，我们把节点13看做X，把节点17看做Y，像刚才的示意图那样进行左旋转：
这样就结束了吗？并没有。因为其中两条路径(17 -&amp;gt; 8 -&amp;gt; 6 -&amp;gt; NIL)的黑色节点个数是4，其他路径的黑色节点个数是3，不符合规则5。
这时候我们需要把节点13看做X，节点8看做Y，像刚才的示意图那样进行右旋转：
如此一来，我们的红黑树变得重新符合规则。这一个例子的调整过程比较复杂，经历了如下步骤：
变色 -&amp;gt; 左旋转 -&amp;gt; 变色 -&amp;gt; 右旋转 -&amp;gt; 变色
几点说明：
关于红黑树自平衡的调整，插入和删除节点的时候都涉及到很多种Case，由于篇幅原因无法展开来一一列举，有兴趣的朋友可以参考维基百科，里面讲的非常清晰。 2.漫画中红黑树调整过程的示例是一种比较复杂的情形，没太看明白的小伙伴也不必钻牛角尖，关键要懂得红黑树自平衡调整的主体思想。</description>
    </item>
    
  </channel>
</rss>
